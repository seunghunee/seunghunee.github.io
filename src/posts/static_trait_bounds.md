---
slug: "/Rust-static 수명의-2가지-의미"
title: "Rust static 수명의 2가지 의미"
description: "Rust의 수명 'static의 2가지 의미와 수명제약(Lifetime Bound)에 대해"
tags: ["Rust", "Ownership", "Lifetime Bound"]
---

# Rust static 수명의 2가지 의미

static, 다른 언어에서도 종종 볼 수 있는 키워드다.
우리말로 번역하면 '정적인'이란 의미로, 소프트웨어 공학에선 _dynamic_(_동적인_)이라는 단어의 반댓말로 쓰이곤 한다.
프로그래밍 언어에선 각 언어에 따라 그리고 이 키워드가 쓰이는 장소에 따라 조금씩 의미가 달라지기 때문에
혼동하지 않도록 주의가 필요한 키워드이다.

Rust에도 static이라는 키워드가 존재한다.
여기선 이 키워드 앞에 `'`가 붙는 `'static` 수명에 대해 살펴본다.
`'static` 수명은 비슷하지만 다른 2가지 형태로 사용될 수 있기 때문에 헷갈리기 싶다.
제대로 이해하면 소유권에 대한 이해를 한층 높일 수 있다.

## 두얼굴의 `'static`

Rust를 배우기 시작한 대부분의 사람들은 다음과 같은 코드로 `'static`을 처음 접하게 된다.

```rust
let hello: &'static str = "안녕";
```

`"안녕"`이라고 하는 문자열의 슬라이스 참조로 변수 `hello`를 초기화하고 동시에 선언하고 있다.
여기서 `'static`은 참조의 _수명_(_lifetime_)으로,
**이 참조는 프로그램이 끝날 때까지 언제나 유효하다**라는 것을 나타낸다.
실제 `"안녕"`이라는 문자열 리터럴은 컴파일될때 이진파일의 특정 영역에 저장되고,
변수 `hello`가 더 이상 사용되지 않는다고 하더라도 해당 이진파일안에 계속 남아있게 된다.

그리고 두번째,

```rust
fn say<T: 'static>(x: T)
```

방금전과 조금 다르다.
얼핏보면 매개변수 `x`에는 "프로그램이 끝날 때까지 유효한"것만 대입할 수 있을 것 같다.
실제 수명이 `'static`보다 짧은 참조를 대입해보면

```rust
let a = 1;
say(&a) // error: `a` does not live long enough
```

대입한 값 `&a`의 참조대상 `a`가 원하는 만큼 오래 살지 않는다는 오류메시지가 뜬다.
역시 매개변수 `x`에는 프로그램이 끝날 때까지 유효한 것만 대입할 수 있었다!
라고 오해하기 쉽다.

위의 2가지 예에선 `'static`이라는 똑같은 키워드가 쓰였지만, 사실 쓰여진 장소를 다시 잘 보면 둘을 쉽게 구분할 수 있다.
전자는 타입표기에 후자는 타입 매개변수의 제약표기에 쓰였다.
이름도 그에 따라 달라서 전자는 참조의 수명, 후자는 타입 매개변수의 **_수명제약_**(**_lifetime bound_**)이라고 한다.
전자의 `'static` 수명은 위에서 설명한대로 프로그램이 끝날 때까지 유효한 참조라는 의미를 지니고 있고, 단순하고 이해하기 쉽다.
이제부턴 혼란의 여지가 있는 후자의 `'static` 수명제약에 대해 자세히 알아본다.

## 온전한 소유

`<T: 'static>`에서 `T`는, `'static` 수명제약이 붙어 **모든 참조들의 수명이 `'static`인 타입**으로 제한된다.
예를들어 앞의 예제에서 설명한 `say`함수의 매개변수에는 다음과 같이 `'static` 수명의 참조를 인수로 대입할 수 있다.

```rust
let hello: &'static str = "안녕";
say(hello); // ok
```

하지만, 수명이 `'static`이 아닌 참조는 대입할 수 없다.

```rust
let hello: &'static str = "안녕";
let hell = &hello;
say(hell); // error: `hello` does not live long enough
```

헷갈릴 수도 있는데 변수 `hello`에 담긴 참조는 수명이 `'static`이지만,
`hell`에 담긴 참조(`&hello`)는 수명이 `'static`이 아니다.
수명이 `'static'`인 참조만 대입할 수 있고 아니면 대입할 수 없으니까
여기까지만 보면 `'static'` 수명이랑 다를게 없어보인다.

그런데 이런게 컴파일되고 만다!

```rust
let s = "hello".to_string();
say(s); // ok
```

`s`는 문자열 슬라이스 참조(`&str`)가 아닌 문자열(`String`)을 담고 있다.
`'static` 수명제약은 **모든 참조들의 수명이 `'static`인 타입**으로 제한하지만,
애초에 `String`은 참조가 아닌 **소유타입(owned type)**[^1]이기 때문에
`'static` 수명제약이 걸린 타입의 매개변수에도 대입할 수 있다.
당연하지만 같은 이유로 `Vec`나 다른 소유타입의 값들도 대입할 수 있다.

그럼 참조를 포함하는 타입은 어떨까?

```rust
let hello: &'static str = "안녕";
let hell = &hello;
let s = S(1, hello, hell); // struct S<'a>(i32, &'static str, &'a &'static str);
say(s); // error: `hello` does not live long enough
```

`s`안에 있는 참조는 2개 있다.
`hello`가 담고있는 참조의 수명은 `'static`으로 문제가 없지만
`hell`이 담고있는 참조의 수명이 `'static`이 아니기 때문에 컴파일에 실패한다.
참조를 아무리 많이 포함하고 있어도 모두 `'static` 수명이면 문제없이 `say`함수에 대입할 수 있지만,
단 하나라도 `'static` 수명이 아닌 참조가 있다면 대입할 수 없게 된다.
이렇게 `'static` 수명제약을 이용하면 `'static` 수명이 아닌 참조를 거를 수 있다.

정리하면 어느 타입 매개변수 `T`에 `'static` 수명제약을 가한다는 말은,
`T`를 빌린(Borrowed)값을 가지고 있지 않은(가지고 있더라고 수명이 `'static`인)
**온전히 소유(Owned)할 수 있는 타입**으로 제한하는 것이라고 말할 수 있다.
또한 `Vec`나 `String`같은 소유타입은 프로그램 도중 언제든지 메모리에서 해제될 수 있기 때문에,
`'static` 수명이 의미하는 "프로그램이 끝날 때까지 항상 유효한 참조"라는 것은
`'static` 수명제약이 의미하는 바와 다르다는 것을 알 수 있다.

그럼 이 온전히 소유한다는 의미가 어떨 때 유용하게 쓰일까?

## `'static` 수명제약의 쓰임새

`'static` 수명제약의 의미와 그 쓰임새는
표준라이브러리의 [`spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html) 함수에서 엿볼 수 있다.

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T,
    F: Send + 'static,
    T: Send + 'static,
```

`spawn` 함수는 새로운 스레드를 생성하는 함수로,
생성할 스레드의 로직을 담고 있는 함수타입 `F` 와 생성된 스레드의 반환값 타입 `T` 에 각각 수명제약 `'static` 이 가해져 있다.
다른 말로 부모스레드와 자식스레드간에 서로 주고 받는 데이터에 `'static` 수명제약이 가해져 있다는 것이고,
이는 온전히 소유할 수 있는 데이터만을 서로 주고 받을 수 있다는 것이다.
따라서 기본적으로 각 스레드의 데이터는 다른 스레드 있는 데이터에 대한 참조를 가질 수 없고, 데이터들은 각각 서로 독립되어 있다.
실제 다음과 같은 코드는 컴파일되지 않는다.

```rust
let x = 1;
thread::spawn(|| {
    say(&x); // `x` does not live long enough
});
```

왜냐하면 스레드를 생성한 부모스레드와 그렇게 생성된 자식스레드중에
누가 먼저 일을 끝내고 사라질지 컴파일러는 알 수가 없기 때문에,
참조하고 있는 값이 사용도중에 메모리 해제되어 무효한 값이 되어버릴 수 있는 참조,
즉 허상포인터(Dangling Pointer)가 될 가능성이 있는 참조는
애초에 다른 스레드에 넘길 수 없도록 안전장치가 마련되어 있는 것이다.
이렇게 러스트의 소유권 시스템은 `'static` 수명제약이라는 장치로
다른 스레드에서 쓰일 데이터에 대해서도 메모리 안정성을 보장한다. (그것도 컴파일타임에)

만약 `'static` 수명으로 착각해 프로그램이 끝날 때까지 유효한 데이터만 다른 스레드에 넘겨줄 수 있다고 잘못 이해하고 있다면,
불필요한 메모리를 계속 점유하는건 아닌가하고 메모리 누수(Memory Leak)를 걱정할 수도 있다.
하지만, 이미 알다시피 `'static` 수명제약의 타입은 소유타입의 값도 대입할 수 있고,
이는 언제든지 필요하지 않을 땐 메모리에서 해제될 수 있다.

## 일반적인 수명제약

앞서 `<T: 'static>` 는 "**`T` 안의 모든 참조들의 수명은 `'static` 이다**"라는 것을 나타낸다고 했다.
사실 엄밀하게는 "**`T` 안의 모든 참조들은 수명의 길이는 `'static` 이상이다**"라고 하는 것이 맞다.
원래 `'static` 수명이 프로그램 전체 실행기간이라는 범위를 나타내니까
수명의 길이가 `'static` 이상이라는 말은 그냥 수명이 `'static` 이라는 말하고 같다.
하지만, 이렇게 말하는 것이 `'static` 이 아닌 수명제약에 대해 얘기하기 쉽다.
일반적인 수명제약 `<T: 'a>` 는 "**`T` 안의 모든 참조들은 수명의 길이가 `'a` 이상이다**"라는 것을 나타낸다.
그래서 이 경우 `T` 의 매개변수에 수명이 `'a` 보다 짧은 참조를 포함한 값은 대입할 수 없다.

[^1]:
    `String` 값은 내부적으로 힙에 할당된 문자열을 가리키는 포인터를 가지고 있지만 외부적(논리적)으로는 소유하고 있다고 표현된다.
    이는 [`PhantomData`](https://doc.rust-lang.org/std/marker/struct.PhantomData.html) 로 구현된다.
