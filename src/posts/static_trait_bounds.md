---
slug: "/Rust-static의-2가지-의미"
title: "Rust static의 2가지 의미"
description: "Rust의 수명 'static의 2가지 의미와 수명제약(Lifetime Bound)에 대해"
tags: ["Rust", "Ownership", "Lifetime Bound"]
---

<!-- 수명은 해당 참조자의 최대 유효 범위를 나타낸다 -->

# Rust static의 2가지 의미

Rust에서 처음 `'static` 이라는 키워드를 봤을 땐
단순히 '프로그램이 끝날 때까지 언제까지나 변하지 않고 유효한 것'을 나타내는 무언가라고 두리뭉실하게 받아들였었다.
하지만, 이런 명확하지 않은 이해는 발목을 잡기 마련이였다.

## 두얼굴의 `'static`

처음 `'static` 이라는 키워드를 본 코드는 이랬다.

```rust
let hello: &'static str = "안녕";
```

여기서 `'static` 은 참조(Reference) 타입의 수명(Lifetime)으로,
"변수 `hello` 에 담겨질 참조는 **프로그램이 끝날 때까지 언제나 유효하다**"라는 것을 나타낸다.
그리고 두번째 만남은 이랬다.

```rust
fn say<T: 'static>(x: T)
```

처음봤을 땐 "아, 매개변수 `x` 에는 '프로그램이 끝날 때까지 유효한' 값만 담을 수 있는 거겠지?" 라고 생각했었다.
그리고 실제 수명이 `'static` 보다 짧은 참조를 대입해보면,
대입한 값의 수명이 짧다는 오류메시지(\`x\` does not live long enough)가 뜬다.
그리고 컴파일에 실패한다.
그래서 더욱 "정말 프로그램이 끝날 때까지 유효한 참조만 대입할 수 있구나!"하고 오해를 가지기 쉽다.

위의 두가지 예에선 `'static` 이라는 똑같은 키워드가 쓰였지만, 사실 쓰여진 장소를 잘 보면 둘을 구분할 수 있다.
전자는 변수의 "타입표기"에서 쓰였고, 후자는 제네릭의 "제약(bounds)표기"에서 쓰였다.
그리고 그 쓰여진 장소에 따라 이름과 의미도 달라지는데,
전자는 참조타입의 "수명"이고, 후자는 타입 매개변수의 "_수명제약_(_lifetime bounds_)"이다.
여기선 전자의 수명에 대해선 다루지 않고 후자의 수명제약의 의미를 이제부터 살펴본다.

## 수명제약 `'static`

`<T: 'static>` 는, "**`T` 안의 모든 참조들의 수명은 `'static` 이다**"라는 것을 나타낸다.
예를들어 다음과 같이 `'static` 수명제약이 걸린 타입의 매개변수에 `'static` 수명을 가지는 참조를 대입할 수 있다.

```rust
let hello: &'static str = "안녕";
say(hello); // Ok
```

왜냐하면 매개변수에 대입되는 인수 `hello` 는 문자열을 가리키는 단하나의 참조를 가지고,
그 참조의 수명은 `'static` 이기 때문이다.
하지만, 수명이 `'static` 이 아닌 참조들은 대입할 수 없다.

```rust
let hello: &'static str = "안녕";
let hell = &hello;
say(hell); // `hell` does not live long enough
```

변수 `hell` 이 담고 있는 참조의 수명은, `hello` 의 수명이 다할 때까지로 `'static` 이 아니기 때문이다.
게다가 이런 참조들이 구조체나 배열같은 복합타입(Compound Type)에 숨어 있더라도 Rust는 찾아낸다! :astonished:

```rust
let hello: &'static str = "안녕";
let hell = &hello;
let s = S(1, hell); // struct S<'a>(i32, &'a &'static str);
say(s); // `hell` does not live long enough
```

`s` 안의 참조 `hell` 의 수명이 `'static` 이 아니기 때문에 컴파일에 실패한다.
이렇게 `'static` 수명제약을 이용하면 `'static` 수명의 참조 이외의 빌린(Borrowing) 값들을 거를 수 있다.
그럼 참조가 아예 없는 복합타입은?

```rust
let s = S(1, 2); // struct S(i32, i32)
say(s); // Ok
```

문제없이 컴파일 된다.
즉, `'static` 수명제약이 걸린 타입의 매개변수에는
`Vec` 나 `String` 같이 **소유타입(owned type)의 값들도** 대입할 수 있다![^1]

```rust
let really = "정말?".to_string();
say(really); // Ok
```

`Vec` 나 `String` 은 프로그램 도중 언제든지 메모리에서 해제될 수 있기 때문에,
`'static` 수명이 의미하는 "프로그램이 끝날 때까지 항상 유효하다"는
`'static` 수명제약이 의미하는 바와 다르다는 것을 알 수 있다.
`'static` 수명제약은 "**온전히 소유할 수 있다**"를 의미한다고 할 수 있다.

그럼 이 의미가 어떨 때 유용하게 쓰일까? :thinking:

## `'static` 수명제약의 쓰임새

`'static` 수명제약의 의미와 그 쓰임새는
표준라이브러리의 [`spawn`](https://doc.rust-lang.org/std/thread/fn.spawn.html) 함수에서 엿볼 수 있다.

```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T,
    F: Send + 'static,
    T: Send + 'static,
```

`spawn` 함수는 새로운 스레드를 생성하는 함수로,
생성할 스레드의 로직을 담고 있는 함수타입 `F` 와 생성된 스레드의 반환값 타입 `T` 에 각각 수명제약 `'static` 이 가해져 있다.
다른 말로 부모스레드와 자식스레드간에 서로 주고 받는 데이터에 `'static` 수명제약이 가해져 있다는 것이고,
이는 온전히 소유할 수 있는 데이터만을 서로 주고 받을 수 있다는 것이다.
따라서 기본적으로 각 스레드의 데이터는 다른 스레드 있는 데이터에 대한 참조를 가질 수 없고, 데이터들은 각각 서로 독립되어 있다.
실제 다음과 같은 코드는 컴파일되지 않는다.

```rust
let x = 1;
thread::spawn(|| {
    say(&x); // `x` does not live long enough
});
```

왜냐하면 스레드를 생성한 부모스레드와 그렇게 생성된 자식스레드중에
누가 먼저 일을 끝내고 사라질지 컴파일러는 알 수가 없기 때문에,
참조하고 있는 값이 사용도중에 메모리 해제되어 무효한 값이 되어버릴 수 있는 참조,
즉 허상포인터(Dangling Pointer)가 될 가능성이 있는 참조는
애초에 다른 스레드에 넘길 수 없도록 안전장치가 마련되어 있는 것이다.
이렇게 러스트의 소유권 시스템은 `'static` 수명제약이라는 장치로
다른 스레드에서 쓰일 데이터에 대해서도 메모리 안정성을 보장한다. (그것도 컴파일타임에 :thumbsup:)

만약 `'static` 수명으로 착각해 프로그램이 끝날 때까지 유효한 데이터만 다른 스레드에 넘겨줄 수 있다고 잘못 이해하고 있다면,
불필요한 메모리를 계속 점유하는건 아닌가하고 메모리 누수(Memory Leak)를 걱정할 수도 있다.
하지만, 이미 알다시피 `'static` 수명제약의 타입은 소유타입의 값도 대입할 수 있고,
이는 언제든지 필요하지 않을 땐 메모리에서 해제될 수 있다.

## 일반적인 수명제약

앞서 `<T: 'static>` 는 "**`T` 안의 모든 참조들의 수명은 `'static` 이다**"라는 것을 나타낸다고 했다.
사실 엄밀하게는 "**`T` 안의 모든 참조들은 수명의 길이는 `'static` 이상이다**"라고 하는 것이 맞다.
원래 `'static` 수명이 프로그램 전체 실행기간이라는 범위를 나타내니까
수명의 길이가 `'static` 이상이라는 말은 그냥 수명이 `'static` 이라는 말하고 같다.
하지만, 이렇게 말하는 것이 `'static` 이 아닌 수명제약에 대해 얘기하기 쉽다.
일반적인 수명제약 `<T: 'a>` 는 "**`T` 안의 모든 참조들은 수명의 길이가 `'a` 이상이다**"라는 것을 나타낸다.
그래서 이 경우 `T` 의 매개변수에 수명이 `'a` 보다 짧은 참조를 포함한 값은 대입할 수 없다.

[^1]:
    `String` 값은 내부적으로 힙에 할당된 문자열을 가리키는 포인터를 가지고 있지만 외부적(논리적)으로는 소유하고 있다고 표현된다.
    이는 [`PhantomData`](https://doc.rust-lang.org/std/marker/struct.PhantomData.html) 로 구현된다.
