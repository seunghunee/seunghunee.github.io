---
slug: "/"
title: ""
description: ""
tags: []
---

# Rust의 전역 변수는 안전하다

_전역 변수_(_Global variable_)는, 꼭 필요하다면 써야겠지만 보통 프로그램을 복잡하게 만들고, 유닛 테스트를 어렵게 만든다고 알려져 있다.
게다가 다른 언어를 사용하다가 Rust를 처음 접하게 되면, 그냥 전역 변수를 쓰지 마라고 일부러 이렇게 만들어 놓았나라는 생각이 들 정도로 복잡하게 보일 수 있다.
하지만 그 만큼 Rust는 전역 변수를 어떻게 선언하고 어떻게 사용할지에 대한 다양한 선택지를 제공하며,
여러가지 언어적 장치로 전역 변수를 안전하게 잘 다룰 수 있도록 안내해 준다.

논란의 대상인 전역 변수를 어떻게 안전하게 다루는지 Rust의 방식을 자세히 알아보자.

## `const`와 `static`

우선 `const`와 `static`이라는 두 키워드에 대해 자세히 알아둘 필요가 있다.
`const`는 이 키워드가 "constant(상수)"라는 영단어에서 왔듯이 `const`를 사용하면 **값을 변경할 수 없는** _상수_(_Constant_)를 선언할 수 있다. 그리고 상수를 선언할 때는 `mut` 키워드를 사용할 수 없다.

```rust
const PI: f64 = 3.141592; // ok
const mut E: f64 = 2.718; // error: const globals cannot be mutable
```

`static`은 "static(고정된, 정적인)"이라는 영단어에서 왔는데, `static`으로 선언하면 **프로그램이 끝날 때까지 유효한 값**으로 할당되는 _정적 변수_(_Static variable_)가 된다. 그리고 정적 **변수**라는 이름에서도 알 수 있듯이 상수와는 다르게 선언할 때 `mut` 키워드를 사용할 수 있고 값을 변경할 수 있다. 다만 그냥 값을 단순한 대입문으로 변경해보면 안전하지 않다고 컴파일러가 에러를 내며 `unsafe` 함수나 `unsafe` 블록을 사용하라고 한다.

```rust
static mut PI: f64 = 3.141592; // ok
PI = 1.0 // error: use of mutable static is unsafe and requires unsafe function or block
```

즉 정적 변수의 값을 단순한 대입문으로 변경하는 것은 안전하지 않다는 것인데, 이유가 무엇이고 어떻게 해결하는지는 조금 뒤에 알아보도록 하고, 상수와 정적 변수의 또 다른 차이점에 주목해 보자. 중요한 차이점중 하나는 바로 컴파일 결과물인 이진 파일의 내부에 값이 저장되는 방법이 다르다는 것이다.

`const`로 선언된 값은 컴파일되면 이 **값이 사용되는 모든 곳에 값이 곧바로 삽입**된다.

```rust
const PI: f64 = 3.141592;

fn main() {
    println!("원주율: {}", PI);
}
```

즉, 위와 같은 코드가 아래와 같은 코드로 번역된다고 볼 수 있다.

```rust
fn main() {
    println!("원주율: {}", 3.141592); // 사용되는 곳에 값이 그대로 삽입된다.
}
```

따라서 `let`이나 `static`으로 선언된 값처럼 메모리에 특정 영역에 저장되는 것이 아니다. 상수가 사용되는 곳에 상수값 자체가 삽입되고 컴파일 후엔 자취를 감춘다.

반면 `static`으로 선언된 값은 **특정 영역에 저장**되고 고유의 메모리 주소도 가진다.
다만 일반적으로 프로그램 실행 도중 영역의 크기가 변하는 스택(Stack)영역이나 힙(Heap)영역과는 다르게, `static`으로 선언된 값이 저장되는 [영역](https://en.wikipedia.org/wiki/Data_segment)은 컴파일될 때 저장공간의 크기와 장소가 결정되고 변하지 않는다. 즉, 하나의 정적 변수가 차지하는 메모리 공간은 프로그램이 실행되어 끝날 때까지 변하지 않으며 한 곳에 "**고정되어(static)**" 쓰인다.
또한 정적 변수는 `Drop`으로 소멸자(Destructor)를 구현해도 호출되지 않는다.

이렇게 값이 저장되는 방법의 차이를 알고 있으면 상황에 따라 더욱 효율적인 선택을 할 수 있다.
예를 들어 `const`으로 선언된 값의 크기가 매우 크고 아주 많은 곳에 삽입된다면 컴파일 결과물의 크기를 비효율적으로 크게 만들 수 있는데, 이럴 때 `const`대신 `static`을 사용해서 값은 한 곳에 저장해 두고 필요한 곳에서 그 값을 읽도록 할 수 있다.

상수와 정적 변수를 이해했다면 전역 상수 혹은 전역 변수는 그리 어렵지 않다.
그냥 상수나 정적 변수를 함수 바깥에 선언하면 된다.

## 안전하게 값 바꾸기

불변값을 전역적으로 사용하는 것은 비교적 간단하다. 문제는 그 값을 바꾸려고 하면 조금 복잡해진다.
앞에서 단순한 대입문으로 정적 변수의 값을 변경하는 것이 안전하지 않다는 것을 알았다.
여기에는 2가지 이유가 있는데, 2가지 모두 정적 변수의 특성에 기인한다. 바로 참조할 수 있는 범위(scope)안의 모든 곳에서 값에 접근할 수 있기 때문이다.

첫번째 이유는 여러 쓰레드에서 하나의 정적 변수에 동시에 접근하는 상황이 발생할 수 있기 때문이다.
정적 변수는 임의의 장소에서 접근할 수 있기 때문에 프로그램이 멀티스레드로 작성되었다면 여러 쓰레드에서 동시에 접근할 수 있다.
그래서 컴파일러는 `static mut`으로 선언된 값이 스레드 안전(Thread safety)하지 않다고 에러를 낸다.
실제 스레드 안전하지 않은 자료구조로 정적 변수를 선언하면 다음과 같은 컴파일 에러를 볼 수 있다.

```rust
use std::cell::Cell; // `Cell`은 `Sync`를 구현하고 있지 않다

static LOG_LEVEL: Cell<u8> = Cell::new(1); // error: `Cell<u8>` cannot be shared between threads safely
```

스레드 안전성을 지키면서 변수의 값을 바꿀 때는 적절한 동기화 장치(Synchronization primitive)를 이용해야 하는데, Rust는 표준 라이브러리 [`std::sync`](https://doc.rust-lang.org/std/sync/)에 마련되어 있다. 예를 들어 동기화 자료구조중 하나인 [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html)를 이용하면 정적 변수를 문제없이 선언할 수 있고, 자료구조가 제공하는 메소드를 이용하여 값을 안전하게 바꿀 수 있다.[^1][^2]

```rust
use std::sync::Mutex; // `Mutex`는 `Sync`를 구현하고 있다

static LOG_LEVEL: Mutex<u8> = Mutex::new(1);
```

두번째 이유는, 컴파일타임에 빌림 검사기(Borrow checker)를 적용할 수 없기 때문이다.
이는 프로그램이 싱글쓰레드로 작성되어 있다고 하더라도 문제가 된다.
일반적으로 `let`으로 선언된 변수에 대해서는 그 소유자의 값이 어떻게 사용되는지 컴파일타임에 분석하는 빌림 검사기를 적용한다. 예를 들어 `mut` 키워드로, 선언된 변수가 가변 변수인지, 어떤 함수에서 값이 변경될 수 있으며 어떤 범위까지는 값이 변경되지 않는지 등을 정적으로 분석할 수 있다.

```rust
let mut log_level: u8 = 1;
show_lev(&log_level); // 함수 안에서 `low_level`의 값이 절대 바뀌지 않는 다는 걸 컴파일러가 확신할 수 있다!
```

그러나 정적 변수는 `let`으로 선언된 변수처럼 단 하나의 소유자(Owner)가 존재하는 것이 아니다. 그리고 임의의 곳에서 접근해서 값을 변경할 수 있기 때문에 컴파일타임 분석이 어렵다.

```rust
static mut LOG_LEVEL: u8 = 1;
lev_up(); // 함수 안에서 `LOG_LEVEL`의 값이 절대 바뀌지 않는다고 컴파일러가 확신할 수 없다!
```

따라서, 일반적으로 값이 변할 수 있는 가변 정적 변수를 안전하게 사용하려면, 컴파일러의 정적인 분석이 어려우므로 내부가변성을 이용해야 하며, 여러 쓰레드로 부터의 경쟁 상태(Race condition)도 피해야 하므로 그 중에서도 적절한 동기화 장치가 마련된 것들을 사용해야 한다.

## 쓰레드 지역 저장소

여러 쓰레드 접근할 수도 있는 정적 변수에 대해 컴파일러가 쓰레드 안전한 자료구조를 사용하도록 알려주는 것은 좋은 것이다.
하지만, 만약에 정적 변수가 특정 쓰레드에서만 사용된다면 동기화 처리는 불필요한 비용이 되어버린다.
이렇게 하나의 쓰레드안에서만 전역으로 사용되는 값을 선언하고 싶을 때는 쓰레드 지역 저장소(Thread local storage)라는 방법을 사용할 수 있다.
Rust에서는 [`thread_local!`](https://doc.rust-lang.org/std/macro.thread_local.html) 매크로로 구현한다.

하나의 쓰레드에서만 사용되기 때문에 동기화 장치들이 필요없다. 즉, `Sync` 특성을 구현하지 않아도 된다.
대신 가변 정적 변수에 대해서는, 앞서 설명했듯, 컴파일타임 빌림 검사기를 적용할 수 없기 때문에 값을 변경하고 싶을 때는 `RefCell`로 런타임 빌림 검사기를 이용하는 방법으로 구현해야 한다. 또한 컴파일타임에 검사가 이루지지 않으므로 런타임에 panic이 일어나지 않도록 주의해서 코드를 작성할 필요가 있다.

## 컴파일타임 초기화와 런타임 초기화

Rust에서 `const`와 `static`으로 상수와 정적 변수를 선언할 때는 반드시 초깃값을 설정해 주어야 한다.

```rust
const PI: f64; // error: free constant item without body
static E: f64; // error: free static item without body
```

C++에서는 컴파일되는 과정에 따라서 전역적인 값을 초기화하는 코드보다 사용하는 코드가 먼저 실행되어 버리는 [경우](https://en.cppreference.com/w/cpp/language/siof)가 있었다. C++은 초기화되지 않은 전역 객체는 자동으로 0으로 초기화하기 때문에 매 컴파일마다 전역 객체의 값이 달라질 수 있고 여러 전역 객체들이 서로 의존하는 경우 문제는 더 심각해 진다. Rust는 **전역 객체를 선언할 때 반드시 초깃값을 명시하도록 강제**하여 이 문제를 해결한다. 그리고 이 초깃값은 [컴파일타임에 계산할 수 있는 값](https://doc.rust-lang.org/reference/const_eval.html)으로만 명시할 수 있다.

그렇다면 컴파일 타임에 초기화를 할 수 없는 경우는 어떻게 해야할까?
가령 프로그램이 시작한 시간이나 데이터베이스에 연결한 후 그 연결 정보를 전역적인 값으로 선언해 사용하는 경우를 예로 들 수 있다.
이들은 컴파일 타임에 초기화 될 수 없다.
프로그램 시작시간은 프로그램이 시작될 때 알 수 있고, 데이터베이스 연결 정보는 연결한 후에야 알 수 있다.
Rust에서는 [`OnceCell`](https://doc.rust-lang.org/stable/std/cell/struct.OnceCell.html)과 [`OnceLock`](https://doc.rust-lang.org/stable/std/sync/struct.OnceLock.html)라는 자료구조를 사용해서 해결한다.
둘 모두 런타임 초기화를 가능하게 한다는 기능은 동일하나 `OnceCell`과 다르게 `OnceLock`은 멀티쓰레드에서 사용할 수 있는 쓰레드 안전한 자료구조이다.

## 그래도 복잡하다

지금까지 Rust에서 전역 변수를 사용하는 방법에 대해 알아봤다.
정리해보자면 전역 변수 하나를 정의하고 사용하는 데에도 Rust에서는 많은 조건들을 따져야 한다.
값을 어떻게 저장할 것인지를 따져야 하고, 가변값인지 불변값인지 따져야 하고, 멀티쓰레드에서 접근 가능 하게 할지 하나의 쓰레드에서만 접근하게 할지를 따져야 하고, 초기값을 컴파일타임에 할당할 수 있는지 런타임에 할당 해야 하는지를 따져야 한다.
여러가지 경우의 수를 따져가며 사용법을 익혀야 하지만 상세한 부분까지 프로그래머가 설정할 수 있고 안전하게 사용할 수 있도록 컴파일러가 안내해주는 것은 Rust의 장점이라 할 수 있다.

[^1]: 예제에서는 `Cell`과의 비교를 위해 `Mutex`를 사용했지만 사실 `u8`과 같은 간단한 정수형은 [`std::sync::atomic`](https://doc.rust-lang.org/std/sync/atomic/index.html)에 선언된 원자형(Atomic type)를 사용하는 것이 더 효율적이다.
[^2]:
    단, 락(Lock)을 사용할 때는 항상 [포이즈닝](https://doc.rust-lang.org/std/sync/struct.RwLock.html#poisoning)과 [데드록](https://en.wikipedia.org/wiki/Deadlock)에 주의해야 한다.
    한 번 포이즈닝된 것은 다시 새로 만들어야 하니까 되도록 쓰기 잠금(Write lock)을 할 때는 panic이 일어나지 않도록 주의하여 프로그래밍 하자.
    그리고 잠금을 걸어야할 자원이 여러개 있을 경우 순서를 잘 생각하지 않으면 데드록에 걸리기 쉽다.
    특히 Rust에서는 잠금 해제를 소유권을 이용해서 사용 범위에서 벗어났을 때 자동으로 해제하기 때문에, 잠금을 걸때 이전의 잠금이 스코프에서 벗어나 해제되어 있는지 확인하지 않으면 싱글스레드여도 데드록에 걸릴 수 있다.
