---
slug: "/"
title: ""
description: ""
tags: []
---

# Rust의 전역 변수는 안전하다

_전역 변수_(_Global variable_)는 보통 프로그램을 복잡하게 만들고, 유닛 테스트를 어렵게 만든다고 알려져 있다.
논란의 대상인 이 전역 변수, Rust에선 과연 어떻게 다룰까?

다른 언어를 사용하다가 Rust를 처음 접하게 되면, 그냥 전역 변수를 사용하지 마라고 일부러 이렇게 만들어 놓았나라는 생각이 들 정도로 조금 복잡하게 보일 수 있다.
물론 Rust의 탓도 없다고는 할 수 없지만, 원래 제대로 다루려면 어려운 전역 변수의 태생적인 성질 탓도 있다.
꼭 필요하다면 써야겠지만, Rust가 전역적인 값를 다루는 방식으로 부터 어떻게 하면 이를 안전하게 다룰 수 있는지 알 수 있다.

## `const`와 `static`

다른 언어와 비슷하게 전역적인 값을 선언할 때는 함수 바깥에 선언한다.
단, 지역 변수를 선언할 때 쓰는 `let` 키워드 대신 `const`나 `static`만 사용할 수 있다.

```rust
const PI: f64 = 3.141592;
static E: f64 = 2.71828;

fn main() {
    println!("원주율: {}", PI);
    println!("자연상수: {}", E);
}
```

사실 예시로 쓰인 원주율과 자연상수와 같은 상수들은 이미 표준라이브러리에 선언된 [값](https://doc.rust-lang.org/std/f64/consts/index.html)이 있으니 필요할 땐 이를 사용하자.

관습에 따라 이름은 영문 대문자로 쓰며 타입과 초깃값을 꼭 명시해야 한다.
선언하는 방법만 알면 사용하는데 크게 어려울 것은 없다.
그리고 `const`와 `static`의 차이는,
`const`는 이 키워드가 상수(constant)라는 영단어에서 왔듯이 한번 선언되면 변경할 수 없는 상수가 되지만,
`static`은 상수가 될 수도 변수가 될 수도 있다. 변수로 만드는 방법은 뒤에서 알아보기로 하고 우선 상수에 집중해 보자.

또 이 둘은 컴파일될 때 값이 저장되는 방법에도 차이가 있다.
`const`로 선언된 상수는 컴파일 타임에 이 상수가 사용되는 모든 곳에 값이 곧바로 삽입된다. 즉, 컴파일뒤의 결과물에선 메모리 주소를 가지지 않는다.
반면 `static`으로 선언된 값은 컴파일 결과물의 [데이터 세그먼트(Data segment)](https://en.wikipedia.org/wiki/Data_segment)라는 영역에 저장되어 고유의 메모리 주소를 가지고 프로그램이 끝날 때까지 어디에서든 접근할 수 있게 된다.
위의 예제 코드를 컴파일한 결과를 코드로 표현하자면 아래와 같을 수 있겠다.

```rust
// 데이터 세그먼트의 메모리 주소 0x5561a9713058에 값 2.71828가 저장되어 있다고 가정

fn main() {
    println!("원주율: {}", 3.141592); // const 값은 호출부에 삽입
    println!("자연상수: {}", *(0x5561a9713058)); // static 값이 저장된 메모리를 참조
}
```

따라서 `const`로 선언된 값의 크기가 매우크고 아주 많은 곳에 삽입된다면 컴파일 결과물의 크기를 비효율적으로 크게 만들 수 있다. 이럴 땐 `static`으로 선언해 메모리 주소를 가지게 하고 이를 참조하도록 바꿀 수 있다.

그리고 함수 안에서도 두 키워드는 쓸 수 있다. 다만 위에서 설명한 컴파일될 때 값이 저장되는 방법은 똑같지만 접근할 수 있는 영역(scope)이 다를 뿐이다. 위와 같이 함수 밖에서 선언하면 프로그램의 모든 부분에서 접근할 수 있지만, 함수 안에서 선언하게 되면 해당 함수 안에서만 접근 가능하다.

```rust
const PI: f64 = 3.141592;

fn f1() {
    static E: f64 = 2.71828;
    println!("원주율: {}", PI);
    println!("자연상수: {}", E);
}

fn f2() {
    println!("원주율: {}", PI);
    println!("자연상수: {}", E); // error: cannot find value `E` in this scope
}
```

물론 함수 내부에서 선언하게 되면 더 이상 전역 상수 혹은 변수는 아니게 된다.

## 컴파일타임 초기화

그리고 Rust에서는 초깃값을 꼭 명시해줘야 한다. 컴파일타임에
그렇게 까지 할 필요가 있는가 하면 [static initialization order fiasco](https://en.cppreference.com/w/cpp/language/siof)
그리고 이 초기화는 컴파일 타임에 계산될 수 있는

- https://doc.rust-lang.org/std/keyword.const.html#compile-time-constants
- https://doc.rust-lang.org/reference/const_eval.html

상수로만 가능.

## 런타임 초기화

컴파일 타임에 초기화를 할 수 없는 경우가 있다.
가령 데이터베이스에 연결하여 그 정보를 전역적인 값으로 쓰고 싶을 때.
OnceCell, OnceLock

## 전역변수는..

내부가변성.
단 const는 안된다.
따라서 static에 적절한 내부가변성을 사용하면 OK
