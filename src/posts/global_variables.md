---
slug: "/"
title: ""
description: ""
tags: []
---

# Rust의 전역 변수는 안전하다

_전역 변수_(_Global variable_)는, 꼭 필요하다면 써야겠지만 보통 프로그램을 복잡하게 만들고, 유닛 테스트를 어렵게 만든다고 알려져 있다.
게다가 다른 언어를 사용하다가 Rust를 처음 접하게 되면, 그냥 전역 변수를 사용하지 마라고 일부러 이렇게 만들어 놓았나라는 생각이 들 정도로 조금 복잡하게 보일 수 있다.
물론 Rust의 탓도 없다고는 할 수 없지만, 원래 안전하게 잘 다루려고 하면 복잡해 지는 전역 변수의 태생적인 성질 탓도 있다.

논란의 대상인 이 전역 변수를 어떻게 하면 안전하게 다룰 수 있는지 Rust의 방식을 통해 알아보자.

## `const`와 `static`

우선 본격적인 주제에 들어가기 앞서 `const`와 `static`이라는 두 키워드에 대해 자세히 알아둘 필요가 있다.
`const`는 이 키워드가 "constant(상수)"라는 영단어에서 왔듯이 `const`로 한번 선언하면 그 **값을 변경할 수 없는** _상수_(_Constant_)가 된다. 상수를 선언할 때 아예 `mut` 키워드를 사용할 수 없다.

```rust
const PI: f64 = 3.141592; // ok
```

```rust
const mut PI: f64 = 3.141592; // error: const globals cannot be mutable
```

`static`은 키워드 그대로 "static(정적인)"라는 영단어에서 왔는데 `static`으로 선언하면 그 값은 **프로그램이 끝날 때까지 유효한** 값으로 할당되는 _정적 변수_(_Static variable_)가 된다. 그리고 정적 **변수**라는 이름에서도 알 수 있듯이 선언할 때 `mut` 키워드를 사용하면 값을 변경할 수 있다. 다만 그냥 값을 변경하면 안전하지 않다고 컴파일러가 에러를 내며 `unsafe` 함수나 block을 사용하라고 한다.

```rust
static mut PI: f64 = 3.141592; // ok
PI = 1.0 // error: use of mutable static is unsafe and requires unsafe function or block
```

즉 정적 변수의 값을 단순한 대입문으로 변경하는 것은 안전하지 않다는 것인데, 이유가 무엇이고 어떻게 해결하는지는 조금 뒤에 알아보도록 하고, 상수와 정적 변수의 중요한 차이점에 주목해 보자. 바로 컴파일될 때 내부적으로 값이 어떻게 저장되는지 그 방법에 주목할 필요가 있다.

`const`로 선언된 값은 컴파일이 되면 이 값이 사용되는 모든 곳에 값이 곧바로 삽입된다.

```rust
const PI: f64 = 3.141592;

fn main() {
    println!("원주율: {}", PI);
}
```

즉, 위와 같은 코드가 아래와 같은 코드로 번역된다고 볼 수 있다.

```rust
fn main() {
    println!("원주율: {}", 3.141592); // 호출되는 곳에 값이 그대로 삽입된다.
}
```

따라서 다른 `let`이나 `static`으로 선언된 값처럼 메모리에 특정 영역에 저장되는 것이 아니다. 컴파일타임에 이미 호출부에 삽입되고 컴파일 후엔 자취를 감춘다.

반면 `static`으로 선언된 값은 특정 영역에 저장되고 고유의 메모리 주소도 가진다.
다만 프로그램이 실행되고 부터 스택(Stack)에 값을 저장하는 `let`과 달리,
`static`으로 선언된 값은 컴파일된 파일의 특정 [영역](https://en.wikipedia.org/wiki/Data_segment)에 저장된다.
컴파일 될 때 저장공간의 크기와 장소가 결정되고 프로그램이 실행되어 끝날 때까지 그 크기와 장소는 변하지 않고 **한 곳에 고정되어(static)** 쓰인다.
프로그램이 끝날 때까지 존재하기에 `static`으로 선언된 값에는 `Drop`으로 소멸자(Destructor)를 구현해도 호출되지 않는다.

이런 저장되는 방법의 차이를 알고 있으면 값에 따라서 상수를 효율적으로 다룰 수 있다.
`const`의 특성상 선언된 값의 크기가 매우 크고 아주 많은 곳에 삽입된다면 컴파일 결과물의 크기를 비효율적으로 크게 만들 수 있는데, 이럴 때 `const`대신 `static`을 사용하면 한 곳에 저장해 두고 필요한 곳에서 그 값을 읽도록 할 수 있다.
Rust에서는 변수라 하더라도 `mut`키워드나 내부가변성(Interior mutability)를 사용하지 않는 한 값을 변경할 수 없기에 상수와 같이 취급할 수 있기 때문이다.

상수와 정적 변수를 이해했다면 전역 상수 혹은 전역 변수는 그리 어렵지 않다.
그냥 상수나 정적 변수를 함수 바깥에 선언하면 된다.

## 안전하게 값 바꾸기

앞에서 단순한 대입문으로 정적 변수의 값을 변경하는 것이 안전하지 않다는 것을 알았다.
여기에는 2가지 이유가 있는데, 2가지 모두 정적 변수의 특성에 기인한다. 바로 참조할 수 있는 범위(scope)안의 모든 곳에서 값에 접근할 수 있기 때문이다.

첫번째 이유는 여러 쓰레드에서 하나의 정적 변수에 동시에 접근하는 상황이 발생할 수 있기 때문이다.
정적 변수는 임의의 장소에서 접근할 수 있기 때문에 프로그램이 멀티스레드로 작성되었다면 여러 쓰레드에서 동시에 접근할 수 있다.
그래서 컴파일러는 `static mut`으로 선언된 값이 스레드 안전(Thread safety)하지 않다고 에러를 낸다.
실제 스레드 안전하지 않은 자료구조로 정적 변수를 선언하면 다음과 같은 컴파일 에러를 볼 수 있다.

```rust
use std::cell::Cell; // `Cell`은 `Sync`를 구현하고 있지 않다

static LOG_LEVEL: Cell<u8> = Cell::new(1); // error: `Cell<u8>` cannot be shared between threads safely
```

스레드 안전성을 지키면서 변수의 값을 바꿀 때는 적절한 동기화 장치(Synchronization primitive)를 이용해야 하는데, Rust는 표준 라이브러리 [`std::sync`](https://doc.rust-lang.org/std/sync/)에 마련되어 있다. 예를 들어 동기화 자료구조중 하나인 [`Mutex`](https://doc.rust-lang.org/std/sync/struct.Mutex.html)를 이용하면 정적 변수를 문제없이 선언할 수 있고, 자료구조가 제공하는 메소드를 이용하여 값을 안전하게 바꿀 수 있다.[^1][^2]

```rust
use std::sync::Mutex; // `Mutex`는 `Sync`를 구현하고 있다

static LOG_LEVEL: Mutex<u8> = Mutex::new(1);
```

두번째 이유는, 컴파일타임에 빌림 검사기(Borrow checker)를 적용할 수 없기 때문이다.
이는 프로그램이 싱글쓰레드로 작성되어 있다고 하더라도 문제가 된다.
일반적으로 `let`으로 선언된 변수에 대해서는 그 소유자의 값이 어떻게 사용되는지 컴파일타임에 분석하는 빌림 검사기를 적용한다. 예를 들어 `mut` 키워드로, 선언된 변수가 가변 변수인지, 어떤 함수에서 값이 변경될 수 있으며 어떤 범위까지는 값이 변경되지 않는지 정적으로 분석할 수 있다.

```rust
let mut log_level: u8 = 1;
lev_up(&mut log_level);
```

그러나 정적 변수는 `let`으로 선언된 변수처럼 단 하나의 소유자(Owner)가 존재하는 것이 아니다. 그리고 임의의 곳에서 접근해서 값을 변경할 수 있기 때문에 컴파일타임 분석이 어렵다.

```rust
static mut LOG_LEVEL: u8 = 1;
lev_up(); // 이 함수안에서 `LOG_LEVEL`의 값을 바꿀 수도, 바꾸지 않을 수도 있다!
```

따라서, 일반적으로 정적 변수를 안전하게 사용하려면 정적인 분석이 어려우니까 내부가변성을 이용해야 하며, 여러 쓰레드로 부터의 경쟁 상태(Race condition)도 피해야 하니까 그 중에서도 적절한 동기화 장치가 마련된 것들을 사용해야 한다.

## 쓰레드 지역 저장소

특정 쓰레드에서만 사용되는 정적 변수에는 동기화 비용을 지불하고 싶지 않다.

## 컴파일타임 초기화와 런타임 초기화

Rust에서 `const`와 `static`으로 상수와 정적 변수를 선언할 때는 반드시 초깃값을 설정해 주어야 한다.

```rust
const PI: f64; // error: free constant item without body
static E: f64; // error: free static item without body
```

C++에서는 컴파일되는 과정에 따라서 전역적인 값을 초기화하는 코드보다 사용하는 코드가 먼저 실행되어 버리는 [경우](https://en.cppreference.com/w/cpp/language/siof)가 있었다. C++은 초기화되지 않은 전역 객체는 자동으로 0으로 초기화하기 때문에 매 컴파일마다 전역 객체의 값이 달라질 수 있고 여러 전역 객체들이 서로 의존하는 경우 문제는 더 심각해 진다. Rust는 **전역 객체를 선언할 때 반드시 초깃값을 명시하도록 강제**하여 이 문제를 해결한다. 그리고 이 초깃값은 [컴파일타임에 계산할 수 있는 값](https://doc.rust-lang.org/reference/const_eval.html)으로만 명시할 수 있다.

그렇다면 컴파일 타임에 초기화를 할 수 없는 경우는 어떻게 해야할까?
가령 프로그램이 시작한 시간이나 데이터베이스에 연결한 후 그 연결 정보를 전역적인 값으로 선언해 사용하는 경우를 예로 들 수 있다.
이들은 컴파일 타임에 초기화 될 수 없다.
프로그램 시작시간은 프로그램이 시작될 때 알 수 있고, 데이터베이스 연결 정보는 연결한 후에야 알 수 있다.

OnceCell, OnceLock

[^1]: 예제에서는 `Cell`과의 비교를 위해 `Mutex`를 사용했지만 사실 `u8`과 같은 간단한 정수형은 [`std::sync::atomic`](https://doc.rust-lang.org/std/sync/atomic/index.html)에 선언된 원자형(Atomic type)를 사용하는 것이 더 효율적이다.
[^2]:
    단, 락(Lock)을 사용할 때는 항상 [포이즈닝](https://doc.rust-lang.org/std/sync/struct.RwLock.html#poisoning)과 [데드록](https://en.wikipedia.org/wiki/Deadlock)에 주의해야 한다.
    한 번 포이즈닝된 것은 다시 새로 만들어야 하니까 되도록 쓰기 잠금(Write lock)을 할 때는 panic이 일어나지 않도록 주의하여 프로그래밍 하자.
    그리고 잠금을 걸어야할 자원이 여러개 있을 경우 순서를 잘 생각하지 않으면 데드록에 걸리기 쉽다.
    특히 Rust에서는 잠금 해제를 소유권을 이용해서 사용 범위에서 벗어났을 때 자동으로 해제하기 때문에, 잠금을 걸때 이전의 잠금이 스코프에서 벗어나 해제되어 있는지 확인하지 않으면 싱글스레드여도 데드록에 걸릴 수 있다.
