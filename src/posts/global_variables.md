---
slug: "/"
title: ""
description: ""
tags: []
---

# Rust의 전역 변수는 안전하다

_전역 변수_(_Global variable_)는 보통 프로그램을 복잡하게 만들고, 유닛 테스트를 어렵게 만든다고 알려져 있다.
논란의 대상인 이 전역 변수, Rust에선 과연 어떻게 다룰까?

다른 언어를 사용하다가 Rust를 처음 접하게 되면, 그냥 전역 변수를 사용하지 마라고 일부러 이렇게 만들어 놓았나라는 생각이 들 정도로 조금 복잡하게 보일 수 있다.
물론 Rust의 탓도 없다고는 할 수 없지만, 원래 제대로 다루려면 어려운 전역 변수의 태생적인 성질 탓도 있다.
꼭 필요하다면 써야겠지만, Rust가 전역적인 값를 다루는 방식으로 부터 어떻게 하면 이를 안전하게 다룰 수 있는지 알 수 있다.

## `const`와 `static`

우선 본격적인 주제에 들어가기 앞서 두 키워드에 대해 자세히 알아둘 필요가 있다.

키워드가 "constant(상수)"라는 영단어에서 왔듯이 `const`로 한번 선언하면 그 값을 변경할 수 없는 _상수_(_Constant_)가 된다.

반면 `static`으로 선언된 값은 프로그램이 끝날 때까지 존재하는 특정 [영역](https://en.wikipedia.org/wiki/Data_segment)에 저장되고 고유의 메모리 주소를 가지고,
`static`으로 선언된 값을 사용하는 모든 곳에서 이 특정 메모리 주소에 저장된 값을 읽는다.
따라서 소유권의 관점에서 보면 사용되는 모든 곳이 프로그램이 끝날 때까지 소유한다고 볼 수 있기 때문에 `static`으로 선언된 값에는 `Drop`으로 소멸자(Destructor)를 구현해도 호출되지 않는다.

이렇게 `static`로 선언한 것을 _정적 변수_(_Static variable_)라고 부르지만 상수가 필요할 때도 사용할 수 있다. Rust에서는 `mut`키워드나 내부가변성(Interior mutability)를 사용하지 않는한 값을 변경할 수 없는 상수와 같이 취급할 수 있기 때문이다. 그래서 `const`의 특성상 선언된 값의 크기가 매우크고 아주 많은 곳에 삽입된다면 컴파일 결과물의 크기를 비효율적으로 크게 만들 수 있는데, 이럴 때 `const`대신 `static`을 사용할 수 있다.

상수와 정적 변수는 함수 안에서도 선언할 수 있다. 위에서 설명한 컴파일될 때 값이 저장되는 방법은 같지만 접근할 수 있는 영역(scope)이 다를 뿐이다. 위와 같이 함수 밖에서 선언하면 프로그램의 모든 부분에서 접근할 수 있지만, 함수 안에서 선언하게 되면 해당 함수 안에서만 접근 가능하다.

```rust
const PI: f64 = 3.141592;

fn f1() {
    static E: f64 = 2.71828;
    println!("원주율: {}", PI);
    println!("자연상수: {}", E);
}

fn f2() {
    println!("원주율: {}", PI);
    println!("자연상수: {}", E); // error: cannot find value `E` in this scope
}
```

물론 함수 내부에서 선언하게 되면 더 이상 전역적인 값은 아니게 된다.

다른 언어와 비슷하게 전역적인 값을 선언할 때는 함수 바깥에 선언한다.
단, 지역 변수를 선언할 때 쓰는 `let` 키워드 대신 `const`나 `static`만 사용할 수 있다.

```rust
const PI: f64 = 3.141592;
static E: f64 = 2.71828;

fn main() {
    println!("원주율: {}", PI);
    println!("자연상수: {}", E);
}
```

사실 예시로 쓰인 원주율과 자연상수와 같은 상수들은 이미 [표준라이브러리에 선언된 값](https://doc.rust-lang.org/std/f64/consts/index.html)이 있으니 필요할 땐 이를 사용하자. 관습에 따라 이름은 스크리밍 스네이크 케이스(SCREAMING_SNAKE_CASE)로 쓰며 타입과 초깃값을 꼭 명시해야 한다.
선언하는 방법만 알면 사용하는데 크게 어려울 것은 없어 보인다.

중요한 것은 `const`와 `static`의 차이인데, 가장 눈여겨 볼 점은 컴파일될 때 값이 저장되는 방법에 있다.
`const`로 선언된 값은 컴파일 타임에 이 값이 사용되는 모든 곳에 값이 곧바로 삽입된다. 위의 예의 컴파일 결과를 코드로 표현하자면 아래와 같이 된다고 할 수 있다.

```rust
fn main() {
    println("원주율": {}", 3.141592); // 값이 사용되는 곳에 바로 삽입
    ...
}
```

## 전역 상수와 전역 변수

함수 바깥에 `const`로 상수를 선언하거나 `static`으로 정적 변수를 선언해서 _전역 상수_(_Global constant_)를 만들 수 있었다.
이들은 어디까지나 상수로써 값이 한 번 선언된 후에는 바뀔 수 없다.
그렇다면 값을 바꿀 수도 있는 전역 변수는 어떻게 만들 수 있을까?

즉, `static`만 쓸 수 있다.
당연하게도 값이 변하지 않는 상수로는 선언할 수 없고, 정적 변수로만 선언 가능하다.
단 const는 안된다.
따라서 static에 적절한 내부가변성을 사용하면 OK

## 컴파일타임 초기화와 런타임 초기화

C++에서는 컴파일되는 과정에 따라서 전역적인 값을 초기화하는 코드보다 사용하는 코드가 먼저 실행되어 버리는 [경우](https://en.cppreference.com/w/cpp/language/siof)가 있었다. C++은 초기화되지 않은 전역 객체는 자동으로 0으로 초기화하기 때문에 매 컴파일마다 전역 객체의 값이 달라질 수 있고 여러 전역 객체들이 서로 의존하는 경우 문제는 더 심각해 진다. Rust는 **전역 객체를 선언할 때 반드시 초깃값을 명시하도록 강제**하여 이 문제를 해결한다. 그리고 이 초깃값은 [컴파일타임에 계산할 수 있는 값](https://doc.rust-lang.org/reference/const_eval.html)으로만 명시할 수 있다.

그렇다면 컴파일 타임에 초기화를 할 수 없는 경우는 어떻게 해야할까?
가령 프로그램이 시작한 시간이나 데이터베이스에 연결한 후 그 연결 정보를 전역적인 값으로 선언해 사용하는 경우를 예로 들 수 있다.
이들은 컴파일 타임에 초기화 될 수 없다.
프로그램 시작시간은 프로그램이 시작될 때 알 수 있고, 데이터베이스 연결 정보는 연결한 후에야 알 수 있다.

OnceCell, OnceLock
