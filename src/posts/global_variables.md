---
slug: "/"
title: ""
description: ""
tags: []
---

# Rust의 전역 변수는 안전하다

_전역 변수_(_Global variable_)는, 꼭 필요하다면 써야겠지만 보통 프로그램을 복잡하게 만들고, 유닛 테스트를 어렵게 만든다고 알려져 있다.
게다가 다른 언어를 사용하다가 Rust를 처음 접하게 되면, 그냥 전역 변수를 사용하지 마라고 일부러 이렇게 만들어 놓았나라는 생각이 들 정도로 조금 복잡하게 보일 수 있다.
물론 Rust의 탓도 없다고는 할 수 없지만, 원래 안전하게 잘 다루려고 하면 복잡해 지는 전역 변수의 태생적인 성질 탓도 있다.

논란의 대상인 이 전역 변수를 어떻게 하면 안전하게 다룰 수 있는지 Rust의 방식을 통해 알아보자.

## `const`와 `static`

우선 본격적인 주제에 들어가기 앞서 `const`와 `static`이라는 두 키워드에 대해 자세히 알아둘 필요가 있다.
`const`는 이 키워드가 "constant(상수)"라는 영단어에서 왔듯이 `const`로 한번 선언하면 그 **값을 변경할 수 없는** _상수_(_Constant_)가 된다. 상수를 선언할 때 아예 `mut` 키워드를 사용할 수 없다.

```rust
const PI: f64 = 3.141592; // ok
```

```rust
const mut PI: f64 = 3.141592; // error: const globals cannot be mutable
```

`static`은 키워드 그대로 "static(정적인)"라는 영단어에서 왔는데 `static`으로 선언하면 그 값은 **프로그램이 끝날 때까지 유효한** 값으로 할당되는 _정적 변수_(_Static variable_)가 된다. 그리고 정적 **변수**라는 이름에서도 알 수 있듯이 선언할 때 `mut` 키워드를 사용하면 값을 변경할 수 있다. 다만 그냥 값을 변경하면 안전하지 않다고 컴파일러가 에러를 내며 `unsafe` 함수나 block을 사용하라고 한다.

```rust
static mut PI: f64 = 3.141592; // ok
PI = 1.0 // error: use of mutable static is unsafe and requires unsafe function or block
```

즉 정적 변수의 값을 단순한 대입문으로 변경하는 것은 안전하지 않다는 것인데, 이유가 무엇이고 어떻게 해결하는지는 조금 뒤에 알아보도록 하고, 상수와 정적 변수의 중요한 차이점에 주목해 보자. 바로 컴파일될 때 내부적으로 값이 어떻게 저장되는지 그 방법에 주목할 필요가 있다.

`const`로 선언된 값은 컴파일이 되면 이 값이 사용되는 모든 곳에 값이 곧바로 삽입된다.

```rust
const PI: f64 = 3.141592;

fn main() {
    println!("원주율: {}", PI);
}
```

즉, 위와 같은 코드가 아래와 같은 코드로 번역된다고 볼 수 있다.

```rust
fn main() {
    println!("원주율: {}", 3.141592); // 호출되는 곳에 값이 그대로 삽입된다.
}
```

따라서 다른 `let`이나 `static`으로 선언된 값처럼 메모리에 특정 영역에 저장되는 것이 아니다. 컴파일타임에 이미 호출부에 삽입되고 컴파일 후엔 자취를 감춘다.

반면 `static`으로 선언된 값은 특정 영역에 저장되고 고유의 메모리 주소도 가진다.
다만 프로그램이 실행되고 부터 스택(Stack)에 값을 저장하는 `let`과 달리,
`static`으로 선언된 값은 컴파일된 파일의 특정 [영역](https://en.wikipedia.org/wiki/Data_segment)에 저장된다.
컴파일 될 때 저장공간의 크기와 장소가 결정되고 프로그램이 실행되어 끝날 때까지 그 크기와 장소는 변하지 않고 **한 곳에 고정되어(static)** 쓰인다.
프로그램이 끝날 때까지 존재하기에 `static`으로 선언된 값에는 `Drop`으로 소멸자(Destructor)를 구현해도 호출되지 않는다.

이런 저장되는 방법의 차이를 알고 있으면 값에 따라서 상수를 효율적으로 다룰 수 있다.
`const`의 특성상 선언된 값의 크기가 매우 크고 아주 많은 곳에 삽입된다면 컴파일 결과물의 크기를 비효율적으로 크게 만들 수 있는데, 이럴 때 `const`대신 `static`을 사용하면 한 곳에 저장해 두고 필요한 곳에서 그 값을 읽도록 할 수 있다.
Rust에서는 변수라 하더라도 `mut`키워드나 내부가변성(Interior mutability)를 사용하지 않는 한 값을 변경할 수 없기에 상수와 같이 취급할 수 있기 때문이다.

상수와 정적 변수를 이해했다면 전역 상수 혹은 전역 변수는 그리 어렵지 않다.
그냥 상수나 정적 변수를 함수 바깥에 선언하면 된다.

## 전역 상수와 전역 변수

함수 바깥에 `const`로 상수를 선언하거나 `static`으로 정적 변수를 선언해서 _전역 상수_(_Global constant_)를 만들 수 있었다.
이들은 어디까지나 상수로써 값이 한 번 선언된 후에는 바뀔 수 없다.
그렇다면 값을 바꿀 수도 있는 전역 변수는 어떻게 만들 수 있을까?

즉, `static`만 쓸 수 있다.
당연하게도 값이 변하지 않는 상수로는 선언할 수 없고, 정적 변수로만 선언 가능하다.
단 const는 안된다.
따라서 static에 적절한 내부가변성을 사용하면 OK

## 컴파일타임 초기화와 런타임 초기화

C++에서는 컴파일되는 과정에 따라서 전역적인 값을 초기화하는 코드보다 사용하는 코드가 먼저 실행되어 버리는 [경우](https://en.cppreference.com/w/cpp/language/siof)가 있었다. C++은 초기화되지 않은 전역 객체는 자동으로 0으로 초기화하기 때문에 매 컴파일마다 전역 객체의 값이 달라질 수 있고 여러 전역 객체들이 서로 의존하는 경우 문제는 더 심각해 진다. Rust는 **전역 객체를 선언할 때 반드시 초깃값을 명시하도록 강제**하여 이 문제를 해결한다. 그리고 이 초깃값은 [컴파일타임에 계산할 수 있는 값](https://doc.rust-lang.org/reference/const_eval.html)으로만 명시할 수 있다.

그렇다면 컴파일 타임에 초기화를 할 수 없는 경우는 어떻게 해야할까?
가령 프로그램이 시작한 시간이나 데이터베이스에 연결한 후 그 연결 정보를 전역적인 값으로 선언해 사용하는 경우를 예로 들 수 있다.
이들은 컴파일 타임에 초기화 될 수 없다.
프로그램 시작시간은 프로그램이 시작될 때 알 수 있고, 데이터베이스 연결 정보는 연결한 후에야 알 수 있다.

OnceCell, OnceLock
